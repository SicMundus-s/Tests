package ITTP.additionalTask;

/**
 * ѕредставим на врем€, что вы black hat, и у вас в распор€жении оказались данные ~30 млн. заказов некоторого сервиса
 * доставки еды за некоторый период 2021 и 2022 года.
 * ѕоверхностный анализ показал, что данные содержат 18 758 328 уникальных телефонов с полным именем клиента, а
 * средн€€ длина полного имени - 20 символов (латинских или кириллических).
 * ƒопустим, вы хотите развернуть веб-сервис, который позволит по номеру телефона найти полное им€ клиента. Ќо вы не
 * хотите оставл€ть следы на диске или в базе данных - придетс€ все держать в пам€ти. Ќо еще вы не хотите зр€ тратить
 * крипту на слишком большой сервер.
 *
 * ѕоэтому давайте оценим, сколько пам€ти займут эти данные:
 * если мы хотим реализовать поиск за посто€нное врем€, т.е. O(1)?
 * если мы хотим зан€ть как можно меньше пам€ти?
 * —амое главное - объ€снить, как вы пришли к той или иной числовой оценке.
 * ћожно выбрать любой €зык программировани€/платформу.
 */
public class BlackHat {
    public static void main(String[] args) {

        /**
         * HashMap.
         * –азмер пам€ти, занимаемой одним элементом массива HashMap, зависит от используемой архитектуры и размера ключа и значени€.
         * ѕредположим, что мы будем использовать 64-битную JVM и что размер ключа и значени€ будет равен суммарной средней длине полного имени и номера телефона (20 + 11 = 31 символ).
         * “огда размер одной записи будет равен примерно 48 байт (2 * 8 байт дл€ ссылок на ключ и значение + 31 * 2 байта дл€ символов).
         *
         * “аким образом, размер пам€ти, занимаемый всей хэш-таблицей, будет примерно равен 1,2 гигабайта (25 млн. элементов * 48 байт/элемент).
         *
         * ≈сли мы хотим зан€ть как можно меньше пам€ти, можно использовать сжатое битовое представление данных, но это затруднит работу с данными и замедлит процесс поиска.
         */
    }
}
